
(* Closure conversion *)

(* Converts an arbitrary CPS term (following the standard
   representation invariants) to one that is just a single
   outer-level Fix (with the body being the entry point
   to the code). All of the functions in the code are
   closed, none takes more than MAX_ARGS arguments, and the
   bodies do not contain Fixes. The functions are only
   referred to through LABEL values (which have global
   scope).

 *)

(* Again, this is based on the ideas presented in "Compiling With
   Continuations" (Appel). However, I make the following changes:

   - I do closure passing, but don't use the closure for recursive
     calls or escapes. You can think of this as environment passing,
     except that some closures are represented flat, so that I
     can't simply "project out" the environment.

   - All functions in the same fix ("friends") always share fate
     regarding closure conversion and their set of free variables.

   - Calls to self/friends never count as a free variable. We
     will already have the environment necessary to pass that to
     friends. In retrospect, this probably wasn't worth the
     trouble, as it introduces a lot of complications into the
     code.

   - I recompute the set of free variables for each function each
     time "C" changes in the iterative procedure. This seems to
     be an oversight/bug in Appel's algorithm.

     *)

(* XXX if I ever generate functions with more than c (c = 2?) args,
   like if I do argument flattening, then I need to change the info
   routine to collect the number of args so that I can later test if
   that number PLUS the number of free variables is greater than
   MAX_ARGS. Right now I just have some slack in MAX_ARGS to account
   for the invariant that no function input takes more than 2 args. 
   Even without argument flattening, this would improve things since
   the optimizer sometimes removes unused arguments to functions.

   ... this should be done now, but I never tested it, because in
       the context of humlock the number of arguments is not really
       limited.

       (perhaps not correct for "friends" with different numbers
        of arguments)
         - tom / 10 Jul 2006
*)

(* PERF: if environment consists of exactly one variable, don't
   put it in a tuple of length one! *)

(* XXX would be a good idea to check the invariant that no function
   variable is defined more than once, because that would lead to some
   really bizarre results that would be hard to track down to the
   violation of this invariant. *)

(* XXX I never generate flat closures, but I should. The code is
   set up, just need to change 'rewrite'. nb: this makes ef_call
   slower *)

structure Closure (* :> CLOSURE *) =
struct

  val debugclo = Params.flag false
      (SOME ("-debugclo", 
             "Debug closure conversion")) "debugclo"

  fun debugdo f = if !debugclo then f () else ()
  fun dprint s = if !debugclo then print ("[CPSCLO] " ^ s ^ "\n") else ()

  (* number of free variables that we can safely tack onto the
     argument list. we lose two because functions generated by
     CPS conversion can have a regular arg and a continuation
     arg. see comment above *)
  (* can have pretty much as many args as we like *)
  val MAX_ARGS = 2048 (* Architecture.NREG - 3 *)

  val MAXRECORD = ToCPS.MAXRECORD


  exception Closure of string

  open CPS

  (* what kind of call sites? *)
  datatype escaping = Escapes | Known

  structure V = Variable

  (* first, we crawl over the term to create an 'info' record for
     each function. We need to know what free variables it has, what
     direct calls it makes, and whether it escapes. Free variables
     don't count direct calls.

     All of this requires that each function is named uniquely and
     that there is no shadowing! This should be the case if the
     expression results from ToCPS. We also assume that all FIX
     expressions with more than one function are actually
     mutually-recursive. If they aren't and have highly disjoint
     sets of free variables (or some escape and some don't), it
     would probably be a good optimization to separate them before
     beginning closure conversion.

     This is the job of the function called "info."

     *)

  (* After doing that, we need to decide which functions will be
     represented with closures. For functions that we know all the
     call sites of, we can avoid creating a closure (good) but then
     have to pass in their free variables when they are called (can
     be bad, since it increases the number of free variables at the
     call site). Functions that live in the same Fix (known as
     "friends") will use the same closure -- this prevents us from
     having to generate mutually-recursive data structures. The
     algorithm for computing the representation of each function is
     as follows.

     Because the decision for one function will be the same for
     all its friends, we just pick a representative function for each
     Fix in the following calculation. 

     FV(f) = set of free variables (will be in the function's
             closure if it is closure-converted or passed as
             extra arguments if non-escaping). This includes the
             free variables of its friends.

     C = set of functions that will be closure-converted

     C0 = functions that escape
     FV0(f) = actual free variables in f (and friends)

     First, for each function f, compute FV at round n as:

        FVn(f) = FVn-1(f) + (FVn-1(g) forall g called in f and friends
                                       where g is not in C)
                          + (h        forall h called in f and friends
                                       where h is in C)
     .. we continue until FVn(f) = FVn-1(f) forall f.
        (This is done by the routine "close_fv.")


     Then, 

        Cm = Cm-1 + { f  |  size (FVn(f)) > MAX_ARGS }

     If Cm = Cm-1, then we are done. Otherwise, begin calculating
     the FV sets again (as C increases, the FV sets shrink since
     more calls are through closures). Since C increases monotonically,
     we can view this as a lexicographic induction with C as the major
     term and the FVs as minor terms--since C can be at most the
     set of all functions and the FVs the set of all variables, the
     iteration terminates.

     This is not optimal, since after reducing the FV sets some
     functions might not need to be in C because they have fewer
     variables. However, long argument lists are rare, so this is
     a good compromise that ensures termination!

     (FYI, this algorithm is the same as in CWC except that I start
      over calculating the free variables whenever C increases
      (because the set of free variables may decrease), and I
      simplify the presentation by picking a representative for
      each Fix. Also, they don't mention that you need to include
      the closure of any function you call directly if that
      function escapes, which is really important.)

     This is the job of the function called "determine."

     *)

  (* after we know which functions must be closure converted (and with
     which free variables), we make another pass over the tree
     converting Fix and App expressions. This is pretty straightforward.

     When we arrive at a call site, or use of a function variable, we
     generate the appropriate kind of call. There are five:

        - (CC) Closure call: There will be a closure variable (c) in
            scope with the same name as the function. Project out
            the first component (f), then call f with c as the new
            final argument.

        - (CF) Closure call to friend (self): There will be a closure
            variable (c) in scope that was passed into this function.
            Call the friend directly (we know its label) with c as the
            final argument.

        - (EF) Escaping occurence of friend (or self): Need to create
            a closure here from the closure variable that was passed
            to this function. Copy the record, and replace the first
            argument with the appropriate function label. This is
            somewhat expensive, but is also a pretty rare use. Note
            that there is no 'direct' analogue of this, because all
            escaping functions are closure converted.

            XXX: for functions with no friends, we don't need to
            copy the closure, but we do.

        - (DC) Direct call: All of the function's free variables will
            also be free at this point. Call the function with the
            free variables in alphabetical order at the end of
            the argument list. The label is known.

        - (DF) Direct call to friend: Similarly, the friend will have
            available all of the free variables--this call is
            identical to a standard Direct Call.

     When we arrive at a Fix, we rewrite each function according to
     how it will be called.

        - esc=true: The Fix needs to be closure converted. Depending
            on how we feel, we can generate one environment value
            that is shared between each closure for the Fix (good if
            the environment is large or there are many functions) or
            we can generate the closure as a flat tuple (good if
            there are few functions or the argument list is very
            short). We generate a closure with the same variable
            name as each function, and translate the body of the
            function to pull each of its free variables out of the
            environment.

        - esc=false: Each function in the fix will be called directly.
            All functions in the same fix take the same list of
            variables, and these are passed in sorted order at
            the end of the argument list. We don't generate any
            closures--all calls know the actual label of the
            function they're calling.

     After this phase, we always use the Label value when referring
     to a function, rather than a variable.

     Performing this conversion is the job of the function called
     "rewrite."
     *)

  (* finally, we make a pass to hoist all function definitions to an
     outer-most Fix. This is pretty simple--now that all the
     functions are closed, we can move them around at will. We just
     do a bottom-up recursion that collects any FIX expressions and
     leaves the rest where they are. Then we put all of the
     functions in one giant mutually-recursive at the outside. This
     is the job of the function "hoist."

     *)


  fun geto s NONE = raise Closure("Closure conversion bug: " ^ s)
    | geto s (SOME x) = x

  (* functions on sets of variables *)
  fun subtract (la, lb) = 
      List.filter (fn v => not (List.exists (fn h => V.eq(v, h)) lb)) la

  fun union (la, nil) = la
    | union (l, h::t) = 
      if List.exists (fn v => V.eq(v, h)) l 
      then union(l,t) 
      else h::union(l,t)

  fun intersect (la, lb) = 
      List.filter (fn v => List.exists (fn h => V.eq(v, h)) lb) la

  fun unique nil = nil
    | unique (h::t) = 
      if List.exists (fn v => V.eq(h, v)) t
      then unique t
      else h::unique t

  fun member (v, nil) = false
    | member (v, h::t) = V.eq (v, h) orelse member (v, t)

  fun sameset (la, lb) = 
      ListUtil.all2 V.eq (ListUtil.sort V.compare la) 
                           (ListUtil.sort V.compare lb)

  type info = { f : V.var, 
                (* number of arguments it takes *)
                nargs : int,
                (* not including direct calls *)
                fv : V.var list, 
                calls : V.var list, 
                esc : bool,
                (* names of other vars in same fix, including self *)
                friends : V.var list }

  (* return of info *)
  type infr = { (* free variables in this expression, not including
                   direct calls *)
                free : V.var list,
                (* functions called directly in this expression *)
                direct : V.var list,
                (* functions I saw escape *)
                escapes : V.var list,
                (* results so far *)
                fns : info list }

  fun getvar (Var u) = [u]
    | getvar _ = []

  fun getvaro (Var u) = SOME u
    | getvaro _ = NONE


  (* debugging print stuff *)

  fun infotosl { f, nargs, fv, calls, esc, friends } =
      [V.tostring f, if esc then "ESC" else "",
       StringUtil.delimit ", " (map V.tostring fv),
       StringUtil.delimit ", " (map V.tostring calls),
       StringUtil.delimit ", " (map V.tostring friends)]

  fun infodtosl { f, fv, esc, friends } =
      [V.tostring f, if esc then "ESC" else "",
       StringUtil.delimit ", " (map V.tostring fv),
       StringUtil.delimit ", " (map V.tostring friends)]

  fun prinfo s l = 
      let in
          print (s ^ "\n");
          print (StringUtil.table 60 (["name  ", "esc?  ", 
                                       "free  ", "calls  ", 
                                       "friends  "] :: 
                                      (map infotosl l)));
          print "\n"
      end

  fun prdinfo m =
      let val l = V.Map.foldr op:: nil m
      in
         print "Determined Info: \n";
         print (StringUtil.table 60 (["name  ", "closure", 
                                      "free  ", "friends  "] :: 
                                     (map infodtosl l)));
         print "\n"
      end

  (* See comment at header of file.

     finbody is the function we are literally in the body of right
     now (and its friends). This does NOT include functions we are
     nested inside. If we see a call to this function, we never need
     its closure, since we can call it with our own environment. *)

  fun info (finbody : V.var list)
           (finscope : V.var list)
           (e : CPS.cexp) : infr =
    let val self = info finbody finscope
    in case e of
        (* Fix is where all the action is. *)
        Fix (vael, ebody) =>
         let
           val these = map (fn (f,_,_) => f) vael
           val finscope = these @ finscope
           fun onefun (f, args, body) =
               let (* recurse, but now finbody = these *)
                   val { free, direct, escapes, fns } = 
                             info these finscope body
               in (f, length args, subtract(free, args), direct, escapes, fns)
               end

           val fnel = map onefun vael

           val allfree = subtract(foldl (fn ((_, _, fr, _, _, _), s) => 
                                         union (s, fr)) nil fnel, these)

           val fns = foldr (fn ((_, _, _, _, _, fns), s) => fns @ s) nil fnel

           val escapes = foldl (fn ((_, _, _, _, esc, _), s) => 
                                union (esc, s)) nil fnel

           val directs = foldl (fn ((_, _, _, di, _, _), s) => 
                                union (di, s)) nil fnel

           val { free=efree, direct=edirect, 
                 escapes=eescapes, fns=efns } = 
                         info finbody finscope ebody

           val fs = map (fn (f, nargs, _, direct, escapes, fns) =>
                         { f=f, 

                           nargs = nargs,

                           (* since they will all share a closure, 
                              free variables are the free
                              variables of all functions unioned
                              together. However, we can always build
                              the closure for a friend, so those are
                              not free. *)
                           fv = allfree,

                           (* direct calls might as well not include 
                              friends, because we already have the 
                              same free variables as those. *)
                           calls = subtract (direct, these),

                           (* escapes in a function body, fix body *)
                           esc = List.exists(fn x => V.eq (x, f)) escapes
                                 orelse List.exists(fn x => V.eq (x, f)) 
                                                    eescapes,

                           (* all including self *)
                           friends = these}) fnel
         in

           { (* free variables are all of the free we saw, minus the bound
                functions, minus the names of the functions we are
                nested within (those are constructed EF above) *)
             free = subtract(subtract (union (allfree, efree), these), 
                             finbody),

             (* ditto direct (we needn't include direct calls to 
                functions nested within ourselves, since obviously we 
                contain all the free variables necessary to call them!) *)
             direct = subtract (union (directs, edirect), these),

             (* similarly, we've already taken care of marking 'these' 
                functions if they've escaped, and they can't escape 
                anywhere else, because this is the extent of their 
                scope *)
             escapes = subtract (union (escapes, eescapes), these),

             (* the new functions we calculated *)
             fns = fs @ fns @ efns}
         end

       (* For a record allocation, simply remove the newly bound variable,
          and mark any function included in a record as 'escaping' *)
      | Alloc (t, vas, v, erest) =>
           let
               val {free, direct, escapes, fns} = self erest
               val used = unique (List.mapPartial getvaro vas)
               val esc = intersect (used, finscope)
           in
               { free = union(subtract (free, [v]), used),
                 direct = direct,
                 escapes = union (escapes, esc),
                 fns = fns }
           end
      | Project (_, va, v, erest) =>
           let
               val {free, direct, escapes, fns} = self erest
           in
               { free = union (subtract (free, [v]), getvar va),
                 direct = direct,
                 escapes = union (intersect(getvar va, finbody), escapes),
                 fns = fns }
           end
      | App (va, vl) =>
           (let val args = List.mapPartial getvaro vl
                val arge = intersect(args, finscope)
            in case getvaro va of
                SOME v => 
                    (if member (v, finscope) 
                     then 
                         let val esc = List.exists(fn z => V.eq(z, v)) args
                         in { 
                              (* don't count this as a free
                                 variable. It may become one in
                                 'determine', but it isn't right
                                 now because we know the label! *)
                              free = args,
                              (* This is a direct call ONLY if the 
                                 function is not one of its own 
                                 arguments. *)
                              direct = if esc then nil else [v],
                              escapes = if esc 
                                        then union(arge, [v]) 
                                        else arge,
                              fns = nil }
                         end
                     (* definition not available *)
                     else { free = unique (v :: args),
                            direct = nil,
                            escapes = arge,
                            fns = nil })
              | NONE => raise Closure 
                         "Impossible: non-var in function position of app"
           end)
      | Intswitch (v, icl, erest) => 
           let
               fun go ({ free, direct, escapes, fns } :: rest) = 
                   let val (f, d, es, fs) = go rest
                   in (union(free, f),
                       union(direct, d),
                       union(escapes, es),
                       fns @ fs)
                   end
                 | go nil = (getvar v, nil, nil, nil)

               val (f, d, es, fs) = go (map (fn (_, ee) => self ee) 
                                                ((0w0,erest)::icl))
           in
               { free = f, direct = d, escapes = es, fns = fs }
           end
      (* same as intswitch, but we bind vr in each arm + default *)
      | Sumswitch (va, num, vr, icl, erest) =>
           let
               val { free=ff, direct=dd, 
                     escapes=eses, fns=fsfs } = self erest

               (* var bound in default too now *)
               val ff = subtract(ff, [vr])

               fun go ({ free, direct, escapes, fns } :: rest) = 
                   let val (f, d, es, fs) = go rest
                   in (union(subtract(free, [vr]), f),
                       union(direct, d),
                       union(escapes, es),
                       fns @ fs)
                   end
                 | go nil = (unique (getvar va @ ff), dd, eses, fsfs)

               val (f, d, es, fs) = go (map (fn (_, ee) => self ee) icl)
           in
               { free = f, direct = d, escapes = es, fns = fs }
           end
      | Primop (_, vl, bound, cl) =>
           let
               val used = List.mapPartial getvaro vl

               fun go ({ free, direct, escapes, fns } :: rest) = 
                   let val (f, d, es, fs) = go rest
                   in (union(free, f),
                       union(direct, d),
                       union(escapes, es),
                       fns @ fs)
                   end
                 | go nil = (used, nil, nil, nil)

               val (f, d, es, fs) = go (map self cl)
           in
               { free = subtract(f, bound), direct = d, 
                 escapes = union(es, intersect(finscope, used)), 
                 fns = fs }
           end
      | Deferred os => 
           (case Util.Oneshot.deref (os()) of
                NONE => raise Closure 
                  "found unset deferred expression in closure conversion"
              | SOME e => self e)
    end

  (* update varmap *)
  fun mapupdate m v f =
      let val (m, a) = V.Map.remove (m, v)
      in V.Map.insert (m, v, f a)
      end

  (* see comment at header of file *)
  fun determine (fns : info list) : 
      { f : V.var, esc : bool, 
        friends : V.var list, fv : V.var list } V.Map.map =
      let
        (* sort by function name. *)
        val fns = ListUtil.sort 
                    (fn ({f=fa, ...}, {f=fb, ...}) => 
                     V.compare (fa, fb)) 
                    fns

        (* get the representative functions for each Fix. 
           These are augmented with all the internal calls,
           free variables, and escapitude of their friends.
           (reps)

           We also generate a map that we use to find the
           representative for any function. (mapup)
           *)
        fun getreps acc mapup ((r as {f, nargs=_, fv, calls, esc, friends})::rest) =
            let
                val friends = ListUtil.sort V.compare friends
            in
                if V.eq (f, hd friends) 
                then (* this will be the rep *)
                    getreps (V.Map.insert (acc, f, r)) 
                            (V.Map.insert (mapup, f, f)) rest
                else 
                    let (* update the representative with this data *)
                        fun up { f=ff, nargs, fv=vv, calls=cc, 
                                 esc=ee, friends=rr } =
                            { f = ff, 
                              nargs = nargs,
                              fv = union(vv, fv), 
                              calls = union(calls,cc),
                              esc = ee orelse esc,
                              friends = rr } : info
                    in getreps (mapupdate acc (hd friends) up) 
                               (V.Map.insert (mapup, f, hd friends)) rest
                    end
            end
          | getreps acc mapup nil = (acc, mapup)

        val (reps : info V.Map.map, 
             mapup : V.var V.Map.map) = getreps V.Map.empty V.Map.empty fns

        (* Get the representative for g *)
        fun domapup g = geto "domapup" (V.Map.find (mapup, g))

        (* C0 = reps where esc = true *)
        (* FV0 is the fv in reps. We maintain a separate map for
           the FVn sets called fvs. *)

        fun close_c reps =
            let

              fun preps m =
                  prinfo "close_c reps"
                  (V.Map.foldr op:: nil m)

              val _ = debugdo (fn () => preps reps)


              val fv0 = V.Map.map (fn ({f, fv, ...} : info) => fv) reps

              fun close_fv fvlast =
                let
                    fun close_one ({ f, nargs, fv, calls, esc, friends }, 
                                   (fvnow, changed)) =
                        let
                            val direct_calls = 
                                List.filter 
                                  (fn g =>
                                   case V.Map.find (reps, domapup g) of
                                       SOME {esc, ...} => not esc
                                     | NONE =>
                                           raise Closure
                                               ("direct call " ^
                                                V.tostring g ^ 
                                                " not in info!"))
                                  calls

                            val oldfvs = 
                                geto "oldfvs" (V.Map.find (fvlast, f))

                            val directfvs = 
                                foldl union nil 
                                   (map (fn z => geto "directfvs" 
                                         (V.Map.find (fvlast, domapup z))) 
                                    direct_calls)

                            (* if any of the functions we call directly 
                               will be closure converted, we need their 
                               closure rather than their FVs. *)
                            val directfvs = 
                                union(directfvs,
                                      List.filter 
                                       (fn g => 
                                        case V.Map.find 
                                              (reps, domapup g) of
                                            SOME {esc, ...} => esc
                                          | NONE =>
                                              raise Closure
                                                  ("direct call " ^
                                                   V.tostring g ^
                                                   " still not in info"))
                                       calls)

                            val newfvs = union(oldfvs, directfvs)
                        in
                            (V.Map.insert (fvnow, f, newfvs), 
                             changed orelse not (sameset (newfvs, oldfvs)))
                        end

                    val (fvnow, changed) = 
                        V.Map.foldl close_one (V.Map.empty, false) reps
                in
                    if changed 
                    then close_fv fvnow
                    else fvnow
                end

              val fvnow = close_fv fv0

              (* now change reps: if fvnow(f) + current_args > MAX_ARGS 
                 then reps.esc = true *)
              fun spill_one (f, fv, (repnow, changed)) =
                  let 
                      val r as { fv=fvorig, nargs, calls, esc, friends, ... } = 
                                     geto "r" (V.Map.find (reps, f))
                  in
                      if nargs + length fv > MAX_ARGS 
                      then (V.Map.insert 
                            (repnow, f, { f=f, fv=fvorig, nargs=nargs,
                                          calls=calls, esc=true, 
                                          friends=friends }),
                            changed orelse not esc)
                      else (V.Map.insert (repnow, f, r), changed)
                  end

              val (repnow, changed) = 
                  V.Map.foldli spill_one (V.Map.empty, false) fvnow
            in
              if changed then close_c repnow
              else (repnow, fvnow)
            end

        val (repnow, fvnow) = close_c reps

      in
          (* now generate the final info for each function. *)
          foldl (fn ({f, ...}, m) =>
                 let val rep = domapup f
                     val {esc, friends, ...} = 
                            geto "final" (V.Map.find (repnow, rep))
                     val fv = geto "fv" (V.Map.find (fvnow, rep))
                 in V.Map.insert (m, f, { f=f, esc=esc, 
                                          friends=friends, 
                                          fv=fv })
                 end) V.Map.empty fns
      end

  (* rewrite fns clos finbody e
     fns = info for each function. (return of determine)
     clos = variable of the closure argument to this function.
            Used for friend-calls, and to generate a new closure
            for an escaping friend. The arity supplied is the
            length of the actual tuple (NOT including chained
            tuples at the end) and is needed for copying.
     finbody = all the friends of the current function body being 
               processed. Calls to these will be done for free (just 
               jump with the current closure), but when these appear
               in a non-call position, we need to generate a new 
               closure for them.
     e = the expression to convert

     rewrites e in closure-converted style according to fns/finbody.
     On return, every Fix in e defines only closed functions.
     *)

  fun rewrite fns clos finbody e =
    let

     (* an escaping value might be a friend variable that we
        need to create a closure for. If it is, create it, and
        also save that variable in case the function escapes
        again in this scope. Call the continuation function on
        the new finbody list and the (possibly changed)
        variable, and wrap that with any bindings we made. *)

     fun eschelp finbody (va as (Var v)) k =
         ( dprint ("eschelp: " ^ V.tostring v);
          case ListUtil.Alist.find V.eq finbody v of
              (* not a friend *)
              NONE => (dprint "not friend.";
                       k (finbody, va))
              (* friend, but already have this closure made *)
            | SOME (SOME vv) => (dprint ("have " ^ V.tostring vv);
                                 k (finbody, Var vv))
            | SOME NONE =>
                  (* (EF) create closure *)
                  (case clos of
                       SOME (cc, arity) =>
                           (* I only need to do a shallow copy. 
                              This is set up to handle flat closures,
                              but right now arity is always 2 because
                              I don't generate flat closures yet.
                              *)
                           let
                               val _ = dprint "copy!"
                               val vv = V.namedvar "ef_closure"

                               (* generate all the projections from 
                                  components 1,..n-1 *)

                               val copity = Int.min(arity, MAXRECORD)

                               fun gencopies n vars kk =
                                   if n >= copity
                                   then kk (rev vars)
                                   else
                                       let val nv = V.namedvar "ef_copy"
                                       in Project(n, cc, nv, 
                                                  gencopies (n + 1) 
                                                      (Var nv::vars) kk)
                                       end

                               val nfib = ListUtil.Alist.update 
                                            V.eq finbody v (SOME vv)
                           in
                               gencopies 1 nil 
                               (fn copies =>
                                Alloc(TUPLE copity, 
                                      Label v :: copies,
                                      vv, 
                                      k (nfib, Var vv)))
                           end
                     | _ => raise Closure 
                           ("Need to create closure for escaping " ^ 
                            "friend, but no arg!")))
       | eschelp finbody va k = k (finbody, va)

     fun eschelpl finbody l k =
         let fun g fib (va :: rest) acc = 
                    eschelp fib va (fn (fib, v) => g fib rest (v::acc))
               | g fib nil acc = k (fib, rev acc)
         in g finbody l nil
         end

    in case e of
       Deferred os => 
           (case Util.Oneshot.deref (os()) of
                (* Would have caught it in info? *)
                NONE => raise Closure "impossible!" 
              | SOME e => rewrite fns clos finbody e)
     | App(Var f, vl) => 
          let
              (* get info for this function. If there's no info, 
                 then it is surely escaping (parameter to a function; 
                 result of projection, etc.) and we are not in its 
                 body, so return something that will cause us to treat
                 it as a closure call. *)

              val (esc, friends, fv) = 
                  (case V.Map.find (fns, f) of
                       SOME {esc, friends, fv, f = _} => (esc, friends, fv)
                     | NONE => (true, nil, nil))
              val fv = ListUtil.sort V.compare fv

          in
              (* distinguish between call types CC, CF, DC, DF *)
              case (esc, ListUtil.Alist.haskey V.eq finbody f) of

                  (true, true) =>
                      (* CF: Known label, use our own closure arg. *)
                      (case clos of
                           SOME (cc, _) => 
                               eschelpl finbody (vl @ [cc])
                               (fn (finbody, args) =>
                                App(Label f, args))
                         | NONE => raise Closure 
                               "Doing CF but no closure in scope")

                | (true, false) =>
                      (* CC: closure in scope. Project and call: *)
                      let val ff = V.namedvar "cc_label"
                      in 
                          Project(0, Var f, ff,
                                  eschelpl finbody (vl @ [Var f])
                                  (fn (finbody, args) =>
                                   App(Var ff, args)))
                      end

                | (false, _) => 
                      (* DF/DC: known label, just pass free variables *)
                      eschelpl finbody (vl @ map Var fv)
                      (fn (finbody, args) =>
                       App(Label f, args))
          end
    | Fix (nil, rest) => rest
    | Fix (vael, rest) =>
       let
           (* fate shared between all functions, 
              so just look at first *)
           val vael = ListUtil.sort 
                          (fn ((v,_,_),(vv,_,_)) => 
                           V.compare (v,vv)) vael
           val (f,_,_) = hd vael
           val {esc, friends, fv, f = _} = geto "fix" (V.Map.find (fns, f))
           val fv = ListUtil.sort V.compare fv

           (* make closures, or not? *)
       in 
         if esc
         then (* yes *)
          let
              (* The idea here is to create one closure for each 
                 of the functions in the fix. Then, we rewrite 
                 each function to first project out the free
                 variables from its last argument. (inside the body,
                 we set clos = SOME c, so that we can rebuild our
                 own closure should we escape.) *)

              (* right now, I always build a separate record for
                 the environment. However, the rest of the code
                 is set up to work with flat closures, so this is
                 a prime candidate for optimization, particularly
                 in the case where there are few (one) functions
                 in the fix. *)

              val env = (V.basename f) ^ "_env"

              val fvl = map Var fv
          in
           (* we might need to generate closures on the fly 
              for some free variables *)
           eschelpl finbody fvl
           (fn (finbody, args) =>
            let
              fun mktuple l k =
                  let val tup = V.namedvar env
                  in
                      if length l > MAXRECORD 
                      then (* XXX use LU.cleave *)
                          let val be = List.take (l, (MAXRECORD - 1))
                              val en = List.drop (l, (MAXRECORD - 1))
                              fun cont v =
                                  Alloc(TUPLE MAXRECORD, 
                                        be @ [v], tup, k (Var tup))
                          in
                              mktuple en cont
                          end
                      else Alloc(TUPLE (length l), l, tup, k (Var tup))
                  end

              fun ourk v =
                (* bind a closure for each one, using the same name. *)
                let
                  fun go nil = 
                    (* bound all the closures, now translate the bodies *)
                    let
                      (* pull out all free variables,
                         then translate body. *)
                      fun unwrap (c : V.var) ee =
                        let
                          fun doproj r nil _ = 
                              (* when all variables projected, 
                                 translate the body *)
                              rewrite fns 
                                (SOME (Var c, 
                                       (* note -- always 2 because
                                          we don't create flat
                                          closures. *)
                                       2
                                       (* include function as well *)
                                       (* length fv + 1 *))) 
                                (map (fn x => (x, NONE)) friends) ee
                            | doproj r [v] n =
                              (* if it's the last var, 
                                 never do chaining. *)
                              Project(n, r, v, doproj r nil (n + 1))
                            | doproj r (v::l) n =
                              if n = MAXRECORD - 1
                              then let val rr = V.namedvar "closure_tail"
                                   in Project(n, r, rr, 
                                              doproj (Var rr) (v::l) 0)
                                   end
                              else Project(n, r, v, doproj r l (n + 1)) 

                          val env = V.namedvar "env"

                          val once = ref false
                        in
                          (case fv of
                               (* env is empty, no need to pull it out *)
                               nil => doproj (Var env) nil 0
                               (* pull out env, 
                                  start projection variables. *)
                             | _ => 
                                   Project(1, Var c, env, 
                                           doproj (Var env) fv 0))
                        end

                      fun one (vv, aa, ee) = 
                        let val c = V.namedvar "closure"
                        in (vv, aa @ [c], unwrap c ee)
                        end
                    in
                      Fix(map one vael,
                          rewrite fns clos finbody rest)
                    end

                  | go ((h,_,_)::t) = 
                    Alloc(TUPLE 2, [Label h, v], h, go t)
                in
                    go vael
                end
            in
                mktuple args ourk
            end)
          end
         else (* no *)
           Fix(let fun one (v, args, body) =
                   (v, args @ fv, 
                    rewrite fns NONE (map (fn x => 
                                           (x, NONE)) friends) body)
               in  map one vael
               end, rewrite fns clos finbody rest)
       end (* Fix *)
    | App _ => raise Closure "Bad CPS: App applied to non-var!"

    | Alloc (t, vas, va, e) =>
          eschelpl finbody vas
          (fn (finbody, nvas) => 
           Alloc(t, nvas, va, rewrite fns clos finbody e))

    | Primop (po, vas, vrs, cs) =>
          eschelpl finbody vas
          (fn (finbody, args) =>
           Primop(po, args, vrs, map (rewrite fns clos finbody) cs))

    | Project (i, va, vr, rest) =>
          eschelp finbody va
          (fn (finbody, vva) =>
           Project(i, vva, vr, rewrite fns clos finbody rest))

    | Intswitch (va, iel, rest) => 
          eschelp finbody va
          (fn (finbody, vva) =>
           Intswitch(vva, 
                     ListUtil.mapsecond (rewrite fns clos finbody) iel,
                     rewrite fns clos finbody rest))

    | Sumswitch (va, num, vr, iel, rest) => 
          eschelp finbody va
          (fn (finbody, vva) =>
           Sumswitch(vva, num, vr, 
                     ListUtil.mapsecond (rewrite fns clos finbody) iel,
                     rewrite fns clos finbody rest))
    end

  (* see comment at header of file. *)

  fun hoist e =
      let
          fun collect e =
              case e of
                  Fix(vael, e) => 
                      let val (fns, ee) = collect e
                          fun one ((v,a,body), fs) =
                              let val (nested, bod) = collect body
                              in (v,a,bod) :: (nested @ fs)
                              end
                      in (foldr one fns vael, ee)
                      end
                | Deferred _ => 
                      (* already removed them *)
                      raise Closure "Impossible!" 
                | App _ => (nil, e)
                | Project(i, vl, vr, rest) => 
                      let val (fns, ee) = collect rest
                      in (fns, Project(i, vl, vr, ee))
                      end
                | Alloc(tag, vas, vr, rest) => 
                      let val (fns, ee) = collect rest
                      in (fns, Alloc(tag, vas, vr, ee))
                      end
                | Primop(po, vll, vrl, restl) =>
                      let val (fns, eel) = 
                          foldr (fn (r, (fns, el)) =>
                                 let val (fs, ee) = collect r
                                 in (fs @ fns, ee :: el)
                                 end) (nil,nil) restl
                      in (fns, Primop(po, vll, vrl, eel))
                      end
                | Intswitch (vl, iel, de) => 
                      let val (fns_start, dee) = collect de
                          val (fns, niel) = 
                              foldr (fn ((i,r), (fns, el)) =>
                                     let val (fs, ee) = collect r
                                     in (fs @ fns, (i, ee) :: el)
                                     end) (fns_start, nil) iel
                      in (fns, Intswitch(vl, niel, dee))
                      end
                | Sumswitch (vl, num, va, iel, de) => 
                      let val (fns_start, dee) = collect de
                          val (fns, niel) = 
                              foldr (fn ((i,r), (fns, el)) =>
                                     let val (fs, ee) = collect r
                                     in (fs @ fns, (i, ee) :: el)
                                     end) (fns_start, nil) iel
                      in (fns, Sumswitch(vl, num, va, niel, dee))
                      end
      in
          Fix(collect e)
      end

  (* stylize the program further; after this
     the program will have the form
     
     Fix(fns, App(Label l, [])) 

     *)
  fun mainify (Fix (fl, c)) =
    let
      val m = Variable.namedvar "mainentry"
    in
      Fix((m, [], c)::fl, App(Label m, []))
    end
    | mainify _ = raise Closure "not hoisted??"

  fun cinfo e = prinfo "final info" (#fns (info nil nil e))
  fun dinfo e = prdinfo (determine (#fns (info nil nil e)))

  (* external interface: 
     run all of the functions above to closure convert a program. *)
  fun convert e =
      let val {fns,...} : infr = info nil nil e
          val _ = debugdo (fn () => prinfo "final info" fns)
          val how = determine fns
          val _ = debugdo (fn () => prdinfo how)
      in mainify (hoist (rewrite how NONE nil e))
      end 
  handle (ex as Closure s) =>
      let in
          print ("Closure conversion failed: " ^ s ^ "\n");
          raise ex
      end
       | x =>
      let in
          print ("Uncaught Exception in Closure Conversion: " ^ 
                 exnName x ^ ": " ^ exnMessage x ^ "\n");
          raise x
      end



end
