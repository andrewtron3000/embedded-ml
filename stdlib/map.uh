val provide-map = ()
val require-list = provide-list

exception Map

type (a, b) map = ( (a -> a -> bool) * ((a * b) list) )

fun map-create keymatchf = (keymatchf, nil)

fun map-manage notfoundf foundf (keymatchf, m) k =
    let
        val (ts, fs) = list-partition (keymatchf k) m
        val new = case ts of 
                      nil => notfoundf ()
                    | x :: nil => foundf x
                    | _ => raise Map (* should be impossible *)
    in
        (keymatchf, new :: fs)
    end

fun map-add (k, nd) m =
    ( map-manage (fn () => (k, nd))
                 (fn (k1, d1) => (k1, nd))
                 m
                 k )

fun map-remove (k, nd) m =
    ( map-manage (fn () => (k, nil))
                 (fn (k1, d1) => (k1, nil))
                 m
                 k )

fun map-lookup k (keymatchf, m) = 
    let
        val x = list-find (keymatchf k) m
    in
        case x of
            SOME (k, d) => SOME d
          | NONE => NONE
    end

