
type marshall_type = 
     { cs : char array,
       byte_offset : int,
       bit_offset : int }

exception Marshall

fun readNextInteger (s, bytes, bits) = 
    let
	val byte_offset = #byte_offset/marshall_type s
	val bit_offset = #bit_offset/marshall_type s
	val cs = #cs/marshall_type s 
    in
	case bytes of 4 =>  
		      ( four-chars-to-int ( sub (cs, byte_offset),
					    sub (cs, byte_offset + 1),
					    sub (cs, byte_offset + 2),
					    sub (cs, byte_offset + 3) ),
			{ cs = cs, 
			  byte_offset = byte_offset + 4,
			  bit_offset = bit_offset } )
		    | 3 => 
		      ( three-chars-to-int ( sub (cs, byte_offset),
					     sub (cs, byte_offset + 1),
					     sub (cs, byte_offset + 2) ),
			{ cs = cs, 
			  byte_offset = byte_offset + 3,
			  bit_offset = bit_offset } )
		    | 2 => 
		      ( two-chars-to-int ( sub (cs, byte_offset),
					   sub (cs, byte_offset + 1) ),
			{ cs = cs,
			  byte_offset = byte_offset + 2,
			  bit_offset = bit_offset } )
		    | 1 => 
		      ( ord (sub (cs, byte_offset)),
			{ cs = cs,
			  byte_offset = byte_offset + 1,
			  bit_offset = bit_offset } )
		    | 0 =>
		      ( case bits of 4 =>
				     let
					 val mask = 0xf0 shr bit_offset
					 val x = ord (sub (cs, byte_offset)) andb mask
					 val a = if bit_offset > 4 
						 then raise Marshall
						 else x shr (4 - bit_offset)
					 val bito = (bit_offset + 4) mod 8
					 val byteo = if bito = 0
						     then byte_offset + 1
						     else byte_offset
				     in
					 ( a, {cs = cs, byte_offset = byteo, bit_offset = bito} )
				     end
				   | 2 => 
				     let
					 val mask = 0xc0 shr bit_offset
					 val x = ord (sub (cs, byte_offset)) andb mask
					 val a = if bit_offset > 6 
						 then raise Marshall
						 else x shr (6 - bit_offset)
					 val bito = (bit_offset + 2) mod 8
					 val byteo = if bito = 0
						     then byte_offset + 1
						     else byte_offset
				     in
					 ( a, {cs = cs, byte_offset = byteo, bit_offset = bito} )
				     end
				   | 1 =>
				     let
					 val mask = 0x80 shr bit_offset
					 val x = ord (sub (cs, byte_offset)) andb mask
					 val a = if bit_offset > 7
						 then raise Marshall
						 else x shr (7 - bit_offset)
					 val bito = (bit_offset + 1) mod 8
					 val byteo = if bito = 0
						     then byte_offset + 1
						     else byte_offset
				     in
					 ( a, {cs = cs, byte_offset = byteo, bit_offset = bito} )
				     end
				   | _ => raise Marshall )
		    | _ => raise Marshall
    end
