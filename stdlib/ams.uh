val require-marshall = provide-marshall
val require-ams-pkts = provide-ams-pkts
val require-ams-state = provide-ams-states
val require-map = provide-map
val require-clock = provide-clock

datatype ams-primitive =
         AMSRegister of string * string * int * int (* app name, auth name, unitID, roleID *)
       | AMSUnregister of int (* node number *)
       | AMSSubscribe of int * int * int * int * int (* subjectID, servicemode, continuumID, unitID, roleID *)
       | AMSUnsubscribe of int * int * int * int (* subjectID, continuumID, unitID, roleID *)
       | AMSPublish of int * int * string (* subjectID, application data length, data *)
       | AMSInboundAAMS of string
       | AMSInboundMAMS of string
       | AMSTimeTick

val AMS_REGISTRATION = 19
val AMS_YOU_ARE_IN = 20
val AMS_I_AM_STARTING = 21
val AMS_I_AM_HERE = 22
val AMS_HEARTBEAT = 1
val AMS_N3 = (10, 0)

(* ams-process-function : (st, msg) -> (st, result) *)
fun ams-process-function (st, msg) =
    let
        (* this is broken!  needs to deal with 16 bit numbers and the
        array needs to be padded if of an odd size, and checksum
        should be returned or should it be inserted? *)
        fun generate-checksum ds =
            let
                fun upd s idx acc =
                    if idx <= (length s) - 2 then
                        let
                            val x1 = sub(s, idx)
                            val x2 = sub(s, idx + 1)
                        in
                            upd s (idx + 2) acc + x1 + x2
                        end
                    else if idx = length(s) - 1 then
                        let
                            val x1 = sub(s, idx)
                        in
                            (acc + x1) andb 0xffff
                        end
                    else
                       (acc andb 0xffff)
            in
                ( upd ds 0 0 ;
                  ds )
            end

        (* *)
        fun update-seq (x :: xs) st = update-seq xs (ams-update-state x st)
          | update-seq nil st = st


        (* *)
        fun process-registration (app, auth, u, r) =
            let
                val st = update-seq ( query_number ((#query_number/ams-statetype st) + 1) ::
                                      app_name app ::
                                      auth_name auth ::
                                      unit u ::
                                      role r :: nil ) st

                val h = { mams_version = 0,
                          mams_checksum = 0, 
                          mams_mpdu_type = AMS_REGISTRATION,
                          mams_sender_venture = #venture/ams-statetype st,
                          mams_sender_unit = #unit/ams-statetype st,
                          mams_role = #role/ams-statetype st,
                          mams_signature_length = 0,
                          mams_supp_data_length = 0, (* this will be updated *)
                          mams_reference = #query_number/ams-statetype st,
                          mams_time_tag = 0 }
                val p = { mams_pdu_header = h,
                          contact_summary = #contact_summary/ams-statetype st }
                val (s, ds) = ams_registration_tostring p
            in
                ( (#mams_sender/ams-statetype st) ds ;
                  (st, true) )
            end

        (* *)
        fun extract-mpdu-id ds = (ord (sub(ds, 0))) andb 0x1f

        (* *)
        fun generate-heartbeat st () =
            let
                val st = ams-update-state (query_number ((#query_number/ams-statetype st) + 1)) st

                val h = { mams_version = 0,
                          mams_checksum = 0, 
                          mams_mpdu_type = AMS_HEARTBEAT,
                          mams_sender_venture = #venture/ams-statetype st,
                          mams_sender_unit = #unit/ams-statetype st,
                          mams_role = #role/ams-statetype st,
                          mams_signature_length = 0,
                          mams_supp_data_length = 0,
                          mams_reference = #query_number/ams-statetype st,
                          mams_time_tag = 0 }
                val hb = { mams_pdu_header = h }
                val (s, ds) = ams_heartbeat_tostring hb
            in
                ( (#mams_sender/ams-statetype st) ds ;
                  (st, true) )
            end

        (* *)
        fun generate-i-am-here st () =
            let
                val h = { mams_version = 0,
                          mams_checksum = 0, 
                          mams_mpdu_type = AMS_I_AM_HERE,
                          mams_sender_venture = #venture/ams-statetype st,
                          mams_sender_unit = #unit/ams-statetype st,
                          mams_role = #role/ams-statetype st,
                          mams_signature_length = 0,
                          mams_supp_data_length = 0,
                          mams_reference = 0,
                          mams_time_tag = 0 }
                val ds = { subscription_list = list-toarray (#subscriptions/ams-statetype st),
                           invitation_list = {| |} }
                val ns = { unit = #unit/ams-statetype st,
                           node_number = #node_id/ams-statetype st,
                           role = #role/ams-statetype st,
                           contact_summary = #contact_summary/ams-statetype st,
                           declaration_struct = ds }
                val iah = { mams_pdu_header = h,
                            node_status_list = {| ns |} }
                val (s, ds) = ams_i_am_here_tostring iah 
            in
                ( (#mams_sender/ams-statetype st) ds ;
                  (st, true) )
            end

        fun process-time-tick () =
            let
                val curr-time = clock-gettime ()
                val dt = clock-sub curr-time (#last_registrar_hb_time/ams-statetype st) 
            in
                if clock-lt AMS_N3 dt then ams-update-state (registrar_dead true) st else st
            end

        (* *)
        fun process-inbound-mams ds =
            let
                val checksum-valid = true (* SUSP - fix this *)
 
                fun process-youarein ds =
                    let
                        val (s, yai) = ams_you_are_in_fromstring ds
                        val id = (#node_number/ams_you_are_in_type yai)
                        val st = update-seq (state MAMS_YOU_ARE_IN ::
                                             node_id id :: nil) st
                    in
                        (st, true)
                    end

                fun add-to-contact-map (node, cs) st = 
                    ams-update-state (node_to_contact_summary_map 
                                          (map-add (node, cs) 
                                                   (#node_to_contact_summary_map/ams-statetype st))) st

                (* *)

                (* note we don't pass (key, data) in here, it's only
                    data.  this is because we can get the key (the
                    subject) from within the subscription assertion
                    that's passed in. *)

                fun add-to-subject-map node sa st =
                    let
                        val subject = #subject/subscription_assert_type sa
                        val r = (node, sa)
                        fun r-eq (n1, s1) (n2, s2) =
                            let
                                val b1 = n1 = n2
                                val b2 = (#subject/subscription_assert_type s1) = 
                                         (#subject/subscription_assert_type s2)
                            in
                                b1 andalso b2
                            end
                        val m = #subject_to_nodes_map/ams-statetype st
                        val others = 
                            case map-lookup subject m of 
                                SOME rs => 
                                let
                                    val (ts, fs) = list-partition (r-eq r) rs
                                in
                                    fs
                                end
                              | NONE => nil
                    in
                        ams-update-state (subject_to_nodes_map
                                          (map-add (subject, r :: others)
                                                   (#subject_to_nodes_map/ams-statetype st))) st
                    end

                fun process-iamstarting ds =
                    let
                        val (s, ias) = ams_i_am_starting_fromstring ds
                        val h = #mams_pdu_header/ams_i_am_starting_type ias
                        val node = #mams_reference/mams_pdu_header_type h
                        val cs = #contact_summary/ams_i_am_starting_type ias
                    in
                        (add-to-contact-map (node, cs) st,
                         true)
                    end

                (* *)
               fun process-iamhere ds =
                    let
                        val (s, iah) = ams_i_am_here_fromstring ds
                        val h = #mams_pdu_header/ams_i_am_here_type iah
                        val nsl = #node_status_list/ams_i_am_here_type iah
                    in
                        (* SUSP in theory we should only see one entry in the nsl *)
                        if (length nsl) = 1 then
                            let
                                val ns = sub (nsl, 0)
                                val node = #node_number/node_status_type ns
                                val cs = #contact_summary/node_status_type ns
                                val ds = #declaration_struct/node_status_type ns
                                val subs = #subscription_list/declaration_struct_type ds
                                val invs = #invitation_list/declaration_struct_type ds
                                val st = add-to-contact-map (node, cs) st
                            in
                                (st, true)
                            end
                        else (st, false)
                    end

                fun process-heartbeat ds =
                    let
                        val (s, hb) = ams_heartbeat_fromstring ds
                        val h = #mams_pdu_header/ams_heartbeat_type hb
                        val (st1, rc1) = generate-heartbeat st ()
                    in
                        (ams-update-state (last_registrar_hb_time (clock-gettime ())) st1, 
                         rc1)
                    end
                                           
            in
                if checksum-valid then 
                    let
                        val mpdu-id = extract-mpdu-id ds
                    in 
                        if mpdu-id = AMS_YOU_ARE_IN then process-youarein ds
                        else if mpdu-id = AMS_HEARTBEAT then process-heartbeat ds
                        else if mpdu-id = AMS_I_AM_HERE then process-iamhere ds 
                        else if mpdu-id = AMS_I_AM_STARTING then 
                            let
                                val (s, r) = process-iamstarting ds
                            in
                                generate-i-am-here s ()
                            end
                        else (st, false)
                    end
                else (st, false)
            end
    in
        case msg of AMSRegister d =>
                    let
                        val () = print "got a registration\n"
                    in
                        process-registration d
                    end
                  | AMSUnregister s =>
                    ( print "got an unregistration\n" ;
                      (st, true) )
                  | AMSPublish (s, l, xs) =>
                    ( print "got a publish request\n" ;
                      (st, true) )
                  | AMSInboundMAMS ds =>
                    ( print "inbound mams message\n" ;
                      print [[chars-tohexstring ds]\n] ;
                      process-inbound-mams ds )
                  | AMSTimeTick =>
                    let
                        val () = print "time tick\n"
                        val st' = process-time-tick ()
                    in
                        (st', true)
                    end
                  | _ => 
                    ( print "got some other crap\n" ;
                      (st, true) )
    end
