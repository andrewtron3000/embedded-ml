val require-string = provide-string
val require-map = provide-map
val require-clock = provide-clock
val require-marshall = provide-marshall
val require-ams-pkts = provide-ams-pkts
val require-ams-state = provide-ams-states

datatype ams-primitive =
         AMSRegister of string * string * int * int (* app name, auth name, unitID, roleID *)
       | AMSUnregister of int (* node number *)
       | AMSSubscribe of int * int * int * int * int (* subjectID, servicemode, continuumID, unitID, roleID *)
       | AMSUnsubscribe of int * int * int * int (* subjectID, continuumID, unitID, roleID *)
       | AMSPublish of int * string (* subjectID, data *)
       | AMSInboundAAMS of string
       | AMSInboundMAMS of string
       | AMSTimeTick

val AMS_HEARTBEAT = 1
val AMS_REGISTRATION = 19
val AMS_YOU_ARE_IN = 20
val AMS_I_AM_STARTING = 21
val AMS_I_AM_HERE = 22
val AMS_SUBSCRIBE = 24
val AMS_UNSUBSCRIBE = 24
val AMS_N3 = (10, 0)
val AMS_UNARY = 0

(* ams-process-function : (st, msg) -> (st, result) *)
fun ams-process-function (st, msg) =
    let
        (* *)
        fun update-seq (x :: xs) st = update-seq xs (ams-update-state x st)
          | update-seq nil st = st

        (* *)
        fun extract-mpdu-id ds = (ord (sub(ds, 0))) andb 0x1f

        (* note we don't pass (key, data) in here, it's only data.
           this is because we can get the key (the subject) from
           within the subscription assertion that's passed in. *)
        fun add-to-subject-map node (sa, st) =
            let
                val subject = #subject/subscription_assert_type sa
                val r = (node, sa)
                fun r-eq (n1, s1) (n2, s2) =
                    let
                        val b1 = n1 = n2
                        val b2 = (#subject/subscription_assert_type s1) = 
                                 (#subject/subscription_assert_type s2)
                    in
                        b1 andalso b2
                    end
                val m = #subject_to_nodes_map/ams-statetype st
                val others = 
                    case map-lookup subject m of 
                        SOME rs => list-filter (fn r1 => not (r-eq r r1)) rs
                      | NONE => nil
                val () = print [added node [int-tostring node] to subject [int-tostring subject]\n]
            in
                ams-update-state (subject_to_nodes_map
                                      (map-add (subject, r :: others)
                                               (#subject_to_nodes_map/ams-statetype st))) st
            end

        (* *)
        fun remove-from-subject-map node (sc, st) =
            let
                val subject = #subject/subscription_cancel_type sc
                fun r-eq (n1, s1) (n2, s2) = n1 = n2
                val m = #subject_to_nodes_map/ams-statetype st
                val others = 
                    case map-lookup subject m of 
                        SOME rs => list-filter (fn r1 => not (r-eq (node, subject) r1)) rs
                      | NONE => nil
                val () = print [removing node [int-tostring node] from [int-tostring subject]\n]
            in
                ams-update-state (subject_to_nodes_map
                                      (map-add (subject, others)
                                               (#subject_to_nodes_map/ams-statetype st))) st
            end

        (* *)
        fun get-dv-from-cs n transport cs =
            let
                fun dv-num-eq n dv = (#delivery_vector_num/delivery_vector_type dv) = n
                val dvs = #delivery_vector_list/contact_summary_type cs
            in
                case array-find (dv-num-eq n) dvs of
                    SOME i => 
                    let
                        val dpns = #delivery_point_names/delivery_vector_type (sub(dvs, i))
                        val names = string-fields (fn ?, => true | _ => false) dpns
                        val name = case list-find (fn x => string-prefix (transport, x)) names of
                                       SOME v => v
                                     | NONE => raise Subscript
                    in
                        name
                    end
                  | NONE => raise Subscript
            end

        (* *)
        fun generate-heartbeat st () =
            let
                val st = ams-update-state (query_number ((#query_number/ams-statetype st) + 1)) st

                val h = { mams_version = 0,
                          mams_checksum = 0, 
                          mams_mpdu_type = AMS_HEARTBEAT,
                          mams_sender_venture = #venture/ams-statetype st,
                          mams_sender_unit = #unit/ams-statetype st,
                          mams_role = #role/ams-statetype st,
                          mams_signature_length = 0,
                          mams_supp_data_length = 0,
                          mams_reference = #query_number/ams-statetype st,
                          mams_time_tag = 0 }
                val hb = { mams_pdu_header = h }
                val (s, ds) = ams_heartbeat_tostring hb
            in
                ( (#mams_sender/ams-statetype st) ds ;
                  (st, true) )
            end

        (* *)
        fun generate-i-am-here st () =
            let
                val h = { mams_version = 0,
                          mams_checksum = 0, 
                          mams_mpdu_type = AMS_I_AM_HERE,
                          mams_sender_venture = #venture/ams-statetype st,
                          mams_sender_unit = #unit/ams-statetype st,
                          mams_role = #role/ams-statetype st,
                          mams_signature_length = 0,
                          mams_supp_data_length = 0,
                          mams_reference = 0,
                          mams_time_tag = 0 }
                val ds = { subscription_list = list-toarray (#subscriptions/ams-statetype st),
                           invitation_list = {| |} }
                val ns = { unit = #unit/ams-statetype st,
                           node_number = #node_id/ams-statetype st,
                           role = #role/ams-statetype st,
                           contact_summary = #contact_summary/ams-statetype st,
                           declaration_struct = ds }
                val iah = { mams_pdu_header = h,
                            node_status_list = {| ns |} }
                val (s, ds) = ams_i_am_here_tostring iah 
            in
                ( (#mams_sender/ams-statetype st) ds ;
                  (st, true) )
            end

        (* *)
        fun process-registration (app, auth, u, r) =
            let
                val st = update-seq ( query_number ((#query_number/ams-statetype st) + 1) ::
                                      app_name app ::
                                      auth_name auth ::
                                      unit u ::
                                      role r :: nil ) st

                val h = { mams_version = 0,
                          mams_checksum = 0, 
                          mams_mpdu_type = AMS_REGISTRATION,
                          mams_sender_venture = #venture/ams-statetype st,
                          mams_sender_unit = #unit/ams-statetype st,
                          mams_role = #role/ams-statetype st,
                          mams_signature_length = 0,
                          mams_supp_data_length = 0, 
                          mams_reference = #query_number/ams-statetype st,
                          mams_time_tag = 0 }
                val p = { mams_pdu_header = h,
                          contact_summary = #contact_summary/ams-statetype st }
                val (s, ds) = ams_registration_tostring p
            in
                ( (#mams_sender/ams-statetype st) ds ;
                  (st, true) )
            end

        (* *)
        fun generate-subscription (subj, service, cont, unit, role) =
            let
                val node = #node_id/ams-statetype st
                val h = { mams_version = 0,
                          mams_checksum = 0, 
                          mams_mpdu_type = AMS_SUBSCRIBE,
                          mams_sender_venture = #venture/ams-statetype st,
                          mams_sender_unit = #unit/ams-statetype st,
                          mams_role = #role/ams-statetype st,
                          mams_signature_length = 0,
                          mams_supp_data_length = 0,
                          mams_reference = node,
                          mams_time_tag = 0 }
                val sa = { subject = subj,
                           continuum = cont,
                           unit = unit,
                           role = role,
                           delivery_vector_num = 0, (* SUSP *)
                           priority = 1,
                           flow = 1 }
                val sm = { mams_pdu_header = h,
                           subscription_assert = sa }
                val (s, ds) = ams_subscription_tostring sm
                val st = add-to-subject-map node (sa, st)
            in
                ( (#mams_sender/ams-statetype st) ds ;
                  (st, true) )
            end

        (* *)
        fun generate-unsubscribe (subj, cont, unit, role) =
            let
                val node = #node_id/ams-statetype st
                val h = { mams_version = 0,
                          mams_checksum = 0, 
                          mams_mpdu_type = AMS_UNSUBSCRIBE,
                          mams_sender_venture = #venture/ams-statetype st,
                          mams_sender_unit = #unit/ams-statetype st,
                          mams_role = #role/ams-statetype st,
                          mams_signature_length = 0,
                          mams_supp_data_length = 0, 
                          mams_reference = node,
                          mams_time_tag = 0 }
                val sc = { subject = subj,
                           continuum = cont,
                           unit = unit,
                           role = role }
                val usm = { mams_pdu_header = h,
                            subscription_cancel = sc }
                val (s, ds) = ams_unsubscribe_tostring usm
                val st = remove-from-subject-map node (sc, st)
            in
                ( (#mams_sender/ams-statetype st) ds ;
                  (st, true) )
            end

        (* *)
        fun process-publish (subj, data) = 
            let
                val node = #node_id/ams-statetype st
                fun publish-msg (n, sa) =
                    case map-lookup n (#node_to_contact_summary_map/ams-statetype st) of 
                        SOME cs => 
                        let
                            val t = #desired_transport/ams-statetype st
                            val dv = get-dv-from-cs (#delivery_vector_num/subscription_assert_type sa) t cs 
                            val h = { aams_version = 0,
                                      aams_message_type = AMS_UNARY,
                                      aams_priority = #priority/subscription_assert_type sa,
                                      aams_reserved1 = 0,
                                      aams_checksum = 0,
                                      (* SUSP this should be source, not destination *)
                                      aams_continuum = #continuum/subscription_assert_type sa, 
                                      aams_unit = #unit/ams-statetype st,
                                      aams_node = node, 
                                      aams_reserved2 = 0,
                                      aams_context = 0,
                                      aams_subject = subj,
                                      aams_app_data_len = length data }
                            val (s, hs) = aams_pdu_header_tostring h
                            val ds = hs ^ data
                            val () = print [sending aams data on subject [int-tostring subj] to node [int-tostring node]\n]
                        in
                            (#aams_sender/ams-statetype st) ds
                        end
                      | NONE => ()
                val ns = case map-lookup subj (#subject_to_nodes_map/ams-statetype st) of 
                             SOME xs => list-filter (fn (n1, _) => n1 <> node) xs
                           | NONE => nil
            in
                ( list-app publish-msg ns ;
                  (st, true) )
            end

        (* *)
        fun process-time-tick () =
            let
                val curr-time = clock-gettime ()
                val dt = clock-sub curr-time (#last_registrar_hb_time/ams-statetype st) 
            in
                if clock-lt AMS_N3 dt then ams-update-state (registrar_dead true) st else st
            end

        (* *)
        fun process-inbound-mams ds =
            let
                val checksum-valid = true (* SUSP - fix this *)
 
                fun process-youarein ds =
                    let
                        val (s, yai) = ams_you_are_in_fromstring ds
                        val id = (#node_number/ams_you_are_in_type yai)
                        val st = update-seq (state MAMS_YOU_ARE_IN ::
                                             node_id id :: nil) st
                    in
                        (st, true)
                    end

                fun add-to-contact-map (node, cs) st = 
                    let
                        val () = print [adding node [int-tostring node] to contact map\n]
                    in
                        ams-update-state (node_to_contact_summary_map 
                                              (map-add (node, cs) 
                                                       (#node_to_contact_summary_map/ams-statetype st))) st
                    end

                (* *)


                fun process-iamstarting ds =
                    let
                        val (s, ias) = ams_i_am_starting_fromstring ds
                        val h = #mams_pdu_header/ams_i_am_starting_type ias
                        val node = #mams_reference/mams_pdu_header_type h
                        val cs = #contact_summary/ams_i_am_starting_type ias
                    in
                        (add-to-contact-map (node, cs) st,
                         true)
                    end

                (* *)
                fun process-iamhere ds =
                    let
                        val (s, iah) = ams_i_am_here_fromstring ds
                        val h = #mams_pdu_header/ams_i_am_here_type iah
                        val nsl = #node_status_list/ams_i_am_here_type iah
                    in
                        (* SUSP in theory we should only see one entry in the nsl *)
                        if (length nsl) = 1 then
                            let
                                val ns = sub (nsl, 0)
                                val node = #node_number/node_status_type ns
                                val cs = #contact_summary/node_status_type ns
                                val decs = #declaration_struct/node_status_type ns
                                val subs = #subscription_list/declaration_struct_type decs
                                val invs = #invitation_list/declaration_struct_type decs
                                val st = add-to-contact-map (node, cs) st
                                val st = array-app-st (add-to-subject-map node) subs st
                            in
                                (st, true)
                            end
                        else 
                            (print "saw more than one entry in nsl...\n";
                             (st, false))
                    end

                (* *)
                fun process-subscription ds =
                    let
                        val (s, sub) = ams_subscription_fromstring ds
                        val h = #mams_pdu_header/ams_subscription_type sub
                        val sa = #subscription_assert/ams_subscription_type sub
                        val node = #mams_reference/mams_pdu_header_type h
                    in
                        (add-to-subject-map node (sa, st),
                         true)
                    end

                (* *)
                fun process-unsubscribe ds =
                    let
                        val (s, unsub) = ams_unsubscribe_fromstring ds
                        val h = #mams_pdu_header/ams_unsubscribe_type unsub
                        val sc = #subscription_cancel/ams_unsubscribe_type unsub
                        val node = #mams_reference/mams_pdu_header_type h
                    in
                        (remove-from-subject-map node (sc, st),
                         true)
                    end

                (* *)
                fun process-heartbeat ds =
                    let
                        val (s, hb) = ams_heartbeat_fromstring ds
                        val h = #mams_pdu_header/ams_heartbeat_type hb
                    in
                        (ams-update-state (last_registrar_hb_time (clock-gettime ())) st, 
                         true)
                    end
                                           
            in
                if checksum-valid then 
                    let
                        val mpdu-id = extract-mpdu-id ds
                    in 
                        if mpdu-id = AMS_YOU_ARE_IN then process-youarein ds
                        else if mpdu-id = AMS_I_AM_HERE then process-iamhere ds 
                        else if mpdu-id = AMS_SUBSCRIBE then process-subscription ds 
                        else if mpdu-id = AMS_UNSUBSCRIBE then process-unsubscribe ds 
                        else if mpdu-id = AMS_HEARTBEAT then 
                            let
                                val (s, r) = process-heartbeat ds
                            in
                                generate-heartbeat s ()
                            end
                        else if mpdu-id = AMS_I_AM_STARTING then 
                            let
                                val (s, r) = process-iamstarting ds
                            in
                                generate-i-am-here s ()
                            end
                        else (st, false)
                    end
                else (st, false)
            end
    in
        case msg of AMSRegister d => process-registration d
                  | AMSUnregister s => (st, true)
                  | AMSSubscribe s => generate-subscription s
                  | AMSUnsubscribe us => generate-unsubscribe us
                  | AMSPublish p => process-publish p
                  | AMSInboundMAMS ds =>
                    ( print [inbound mams: [chars-tohexstring ds]\n] ;
                      process-inbound-mams ds )
                  | AMSTimeTick => (process-time-tick (), true)
                  | _ => 
                    ( print "got some other crap\n" ;
                      (st, true) )
    end
