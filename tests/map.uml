let
    import "std.uh"
    import "list.uh"
    import "string.uh"
    import "int.uh"
    import "array.uh"
    import "char.uh"
    import "growarray.uh"
    import "map.uh"

    val initial-map = map-new (fn desiredk (k1, d1) => desiredk = k1)

    (* *)
    fun add-to-subject-map m (newsubject, newnodeid) =
        ( map-manage (fn () => (newsubject, newnodeid :: nil))
                     (fn (k1, d1) => if (list-exists (fn n => n = newnodeid) d1)
                                     then (k1, d1)
                                     else (k1, newnodeid :: d1))
                     m
                     newsubject )
        
    (* *)
    fun remove-from-subject-map m (subject, nodeid) =
        ( map-manage (fn () => (subject, nil))
                     (fn (k1, d1) => (k1, list-filter (fn n => if n = nodeid then false else true) d1))
                     m
                     subject )
  
    val m = add-to-subject-map initial-map (1, 100)
    val m = add-to-subject-map m (1, 101)
    val m = add-to-subject-map m (1, 102)
    val m = add-to-subject-map m (2, 200)

    val t1 = map-lookup m 1

    fun pis nil = print "\n"
      | pis (i :: is) = ( print [ [int-tostring i] ] ;
                          pis is )

    fun test t =
        case t of 
            SOME ns => pis ns
          | NONE => print [nothing found\n]

in
    (test (map-lookup m 1) ;
     test (map-lookup m 2) ;
     test (map-lookup m 3) )
end
