let
    import "std.uh"
    import "random.uh"
    import "string.uh"
    import "int.uh"
    import "array.uh"
    import "growarray.uh"
    import "char.uh"
    import "time.uh"
    import "io.uh"
    import "list.uh"
    import "threads.uh"
    import "queues.uh"
    import "messagequeues.uh"
    import "tasks.uh"
    import "robin.uh"
    import "descriptorio.uh"
    import "clock.uh"

    (* PMAD ---> uController *)
    val outbound-robin-queue = mq-create ()

    (* PMAD <--- uController *)
    val inbound-robin-queue = mq-create ()
			     
    fun process-key k =
	case k of
	    ?4 => mq-send outbound-robin-queue (Robin-message (2, {| chr 4, chr 4, chr 1 |})) (* turn on *)
	  | ?5 => mq-send outbound-robin-queue (Robin-message (2, {| chr 4, chr 5, chr 1 |})) (* turn on *)
	  | ?6 => mq-send outbound-robin-queue (Robin-message (2, {| chr 4, chr 6, chr 1 |})) (* turn on *)
	  | ?7 => mq-send outbound-robin-queue (Robin-message (2, {| chr 4, chr 7, chr 1 |})) (* turn on *)
	  | ?$ => mq-send outbound-robin-queue (Robin-message (2, {| chr 4, chr 4, chr 0 |})) 
	  | ?% => mq-send outbound-robin-queue (Robin-message (2, {| chr 4, chr 5, chr 0 |})) 
	  | ?^ => mq-send outbound-robin-queue (Robin-message (2, {| chr 4, chr 6, chr 0 |})) 
	  | ?& => mq-send outbound-robin-queue (Robin-message (2, {| chr 4, chr 7, chr 0 |})) 
	  | ?a => mq-send outbound-robin-queue (Robin-message (2, {| chr 4, chr 13, chr 1 |})) (* turn on *)
	  | ?b => mq-send outbound-robin-queue (Robin-message (2, {| chr 4, chr 13, chr 0 |})) (* turn off *)
	  | ?c => mq-send outbound-robin-queue (Robin-message (2, {| chr 1, chr 1, chr 1, chr 1, chr 1, chr 1, chr 1, chr 1 |})) (* set time *)
	  | ?d => mq-send outbound-robin-queue (Robin-message (2, {| chr 6, chr 0, chr 10, chr 1, chr 1, chr 1, chr 1, chr 1, chr 1, chr 3, chr 4, chr 13, chr 1 |})) (* set time rule 0 *)
	  | ?e => mq-send outbound-robin-queue (Robin-message (2, {| chr 6, chr 1, chr 10, chr 1, chr 1, chr 1, chr 1, chr 1, chr 1, chr 3, chr 4, chr 4, chr 1 |})) (* set time rule 1 *)
	  | ?f => mq-send outbound-robin-queue (Robin-message (2, {| chr 6, chr 2, chr 10, chr 1, chr 1, chr 1, chr 1, chr 1, chr 1, chr 3, chr 4, chr 5, chr 1 |})) (* set time rule 2 *)
	  | _ => ()

    fun rx-f st m = case m of Robin-message (s, ds) => 
			      ( descriptor-write (2, [[chars-tohexstring ds]\n]) ;
				st )
			    | _ => st

    fun time-loop (s, ns) () = 
        let
            val (s', ns') = clock-gettime ()
        in
            ( if (s' > s) then
                  if (s' mod 2) = 0
                  then process-key ?4
                  else process-key ?$
              else () ;
              yield () ;
              time-loop (s', ns') () )
        end

    fun idle-loop () = ( yield () ; idle-loop () )

in
    (* The following task waits on the outbound ROBIN queue and sends
    packets to the microcontroller. *)
    task-create outbound-robin-queue (robin-sender putc 1) 0;

    (* The following task waits on the inbound ROBIN queue and calls
    pmad-rx-f on each message received.
     *)
    task-create inbound-robin-queue rx-f 0;

    (* The following tasks receives individual characters and outputs robin packets. *)
    fork (robin-receiver getc availc0 inbound-robin-queue) ;

    (* do something periodically *)
    fork ( time-loop (clock-gettime ()) ); 

    idle-loop ()
end
