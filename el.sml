
(* The External Language *)

structure EL =
struct

  type intconst = Word32.word

    datatype exp_ =

        Constant of constant
      | Var of string
      | Modvar of string * string
      | Float of real

      | App of exp * exp

      | Let of dec * exp

      | Record of (string * exp) list
      (* vector constructor *)
      | Vector of exp list
      (* #label/typ exp *)
      | Proj of string * typ * exp
     
      | Andalso of exp * exp
      | Orelse of exp * exp
      | Andthen of exp * exp
      | Otherwise of exp * exp
      | If of exp * exp * exp

      | Seq of exp * exp
      | Constrain of exp * typ

      (* same as concat, maybe worth making efficient *)
      | Jointext of exp list

      | Raise of exp
      | Handle of exp * (pat * exp) list

      (* optional delayed default can only be generated by the compiler *)
      | Case of exp list * (pat list * exp) list * (unit -> exp) option

      (* throw e1 to e2 *)
      | Throw of exp * exp
      | Letcc of string * exp

      (* compile-time warning if this code is live *)
      | CompileWarn of string

    and constant =
        CInt of intconst
      | CString of string
      | CChar of char

    and pat =
        PVar of string
      | PWild
      | PAs of string * pat
      | PRecord of (string * pat) list
      | PConstrain of pat * typ
      | PConstant of constant
      | PApp of string * pat option
      | PWhen of exp * pat

    and typ =
        TVar of string
      | TApp of typ list * string option * string
      | TRec of (string * typ) list
      | TArrow of typ * typ
      | TModvar of string * string
      (* shortcut for tuple length *)
      | TNum of int

    and dec_ =
        (* wish we had refinements here. 
           val pat cannot contain PConstant or PApp *)
        (* val (a, b) loop = Util.loop : a -> b *)
        Val of string list * pat * exp
      | Do of exp
      | Type of string list * string * typ

      (* XXX hard to support because elabd produces
         new context, not list of decls *)
      (* | Local of dec * dec list *)

      (* fun (a, b, c) f p1 p2 p3 : t1 = e1
           |           f p1 p2 p3 : t2 = e2
         and g p1 p2 : t3 = e3
           | ... *)
      (* f foo : t   --  bind f to native function foo *)
      | Native of string * string * typ
      | Fun of (string list * string * 
                (pat list * typ option * exp) list) list

      (* datatype (a, b, c) t = A of t | B of b | C of t1
         and                u = D of u | E of t *)
      | Datatype of string list * 
                    (string * (string * typ option) list) list
      | Tagtype of string
        (* newtag Fail of string in exn *)
      | Newtag of string * typ option * string
        (* just means newtag E of TO in "exn" *)
      | Exception of string * typ option
        (* more like 'extern' than ML signatures *)
      | Signature of string option * strdec list


    and strdec =
        SVal of string list * string * typ
        (* abstract types *)
      | SType of string list * string
        (* can't really write this externally *)
      | SPrim of string list * string * typ * Primop.primop
        (* ... eventually add types, etc. *)

    (* fixity decls are handled at parse time *)

    withtype exp = exp_ * Pos.pos
    and dec = dec_ * Pos.pos

end
